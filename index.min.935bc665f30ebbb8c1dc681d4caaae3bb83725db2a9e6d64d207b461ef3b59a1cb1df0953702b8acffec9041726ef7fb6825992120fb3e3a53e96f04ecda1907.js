var suggestions=document.getElementById("suggestions"),search=document.getElementById("search");search!==null&&document.addEventListener("keydown",inputFocus);function inputFocus(e){e.ctrlKey&&e.key==="/"&&(e.preventDefault(),search.focus()),e.key==="Escape"&&(search.blur(),suggestions.classList.add("d-none"))}document.addEventListener("click",function(e){var t=suggestions.contains(e.target);t||suggestions.classList.add("d-none")}),document.addEventListener("keydown",suggestionFocus);function suggestionFocus(e){const s=suggestions.classList.contains("d-none");if(s)return;const t=[...suggestions.querySelectorAll("a")];if(t.length===0)return;const n=t.indexOf(document.activeElement);if(e.key==="ArrowUp"){e.preventDefault();const s=n>0?n-1:0;t[s].focus()}else if(e.key==="ArrowDown"){e.preventDefault();const s=n+1<t.length?n+1:n;t[s].focus()}}(function(){var e=new FlexSearch.Document({tokenize:"forward",cache:100,document:{id:"id",store:["href","title","description"],index:["title","description","content"]}});e.add({id:0,href:"/resourge-react-form/docs/prologue/introduction/",title:"Introduction",description:"React Form is a easy and stable way to create forms on your website following the best practices.",content:`Quick Start # One page summary of how to start a creating form with react form. Quick Start →
Help # How to verify if has a new version. Help →
`}),e.add({id:1,href:"/resourge-react-form/docs/api/",title:"Api",description:"Api React Form.",content:""}),e.add({id:2,href:"/resourge-react-form/docs/prologue/",title:"Prologue",description:"Prologue React Form.",content:""}),e.add({id:3,href:"/resourge-react-form/docs/prologue/quick-start/",title:"Quick Start",description:"Quick Start creating forms with react-form.",content:`Compatible # React — ReactJS React Native — React Native for mobile Installation # Using Yarn yarn add @resourge/react-form Using npm npm install @resourge/react-form --save Usage # const { form, // Form Data touches, isTouched, // Form touches errors, isValid, // Form validation context, // Context triggerChange, reset, merge, handleSubmit, field, onChange, getValue, changeValue,changeValue, resetTouch, getErrors, setError, hasError, watch, undo, redo } = useForm(formData, formOptions) useForm is the hook necessary to create forms. Using formData and formOptions, the hook returns an array containing the form state and the form actions.
Example # Demonstration of a example of a simple form.
import React, { useState } from 'react'; import { useForm } from '@resourge/react-form'; export default function Form() { const { isValid, field, handleSubmit } = useForm( { name: 'Rimuru' } ) const onSubmit = handleSubmit((form) =\u0026gt; { // Output of form data console.log('Form data', form) }) return ( \u0026lt;form onSubmit={onSubmit}\u0026gt; \u0026lt;input { ...field('name') }/\u0026gt; \u0026lt;span\u0026gt; { isValid ? \u0026quot;Valid\u0026quot; : \u0026quot;Invalid\u0026quot; } Form \u0026lt;/span\u0026gt; \u0026lt;button type=\u0026quot;submit\u0026quot;\u0026gt; Save \u0026lt;/button\u0026gt; \u0026lt;/form\u0026gt; ); } Usage of form tag Usage of form as wrapper is optional. Known Bugs # Let\u0026rsquo;s us know if any here. `}),e.add({id:4,href:"/resourge-react-form/docs/api/form-actions/",title:"Actions",description:"Methods available to controll the form.",content:`field # Method to connect the form element to the key by providing native attributes like onChange, name, etc.
const { field } = useForm( { name: 'Rimuru' } ) \u0026lt;input {...field('name')} /\u0026gt; /// For validating when changing the value without triggering the submit to get the error validation \u0026lt;input {...field('name', { validate: true })} /\u0026gt; triggerChange # Method to make multiple changes in one render.
const { triggerChange } = useForm( { name: 'Rimuru' } ) triggerChange((form) =\u0026gt; { form.name = 'Rimuru_edited'; }) handleSubmit # Method to handle form submission and prevent the submission if theres errors.
const onSubmit = handleSubmit((form) =\u0026gt; { /// Will only be called when form is valid /// do something with it }) // const onSubmit = handleSubmit( (form) =\u0026gt; { /// Will always be called /// because the next method returns true /// do something with it }, (errors) =\u0026gt; true ) Form Data # Form data is the default form values. Can be a simple object or a class (I made it specifically for class support)
Rules:
Only constrains Form Data to an object. Meaning that it\u0026rsquo;s possible to have elements with moment, dayjs, class's, luxonas, etc. Cached on the first render (changes will not affect the form data). Example with plain object
// definition of a plain object const user = { name: 'Rimuru', age: 39 } // usage with an object const { ... } = useForm( user ) Example with Class
// definition of class class User { name = 'Rimuru'; age = 39 get fullName() { return \`\${this.name} Tempest\` } } // usage with a class const { ... } = useForm( new User() ) watch # Executes methods when \u0026ldquo;watched key\u0026rdquo; is touched.
const { watch } = useForm( { name: 'Rimuru' } ) ... // When 'name' is \`touched\` it will update again with the new name // It does not rerender again, its a one time deal for every watch // Order is important as well, as it will be executed by order in render watch('name', (form) =\u0026gt; { form.name = 'Rimuru Tempest'; }) setError # Method to set custom errors.
const { setError } = useForm( { name: 'Rimuru' } ) ... setError([ { key: 'name', message: 'Beautiful name' } ]) hasError # Returns a boolean for the matched key.
const { hasError } = useForm( { product: { name: 'Apple', category: { name: 'Food', type: { name: 'Solid', type: 'Vegetal' } } } } ) ... hasError('product.category') /// Can return (depends on the validation) getErrors # Returns error messages for the matched key.
const { getErrors } = useForm( { product: { name: 'Apple', category: { name: 'Food', type: { name: 'Solid', type: 'Vegetal' } } } } ) ... getErrors('product.category') /// [\u0026lt;\u0026lt;Error Messages\u0026gt;\u0026gt;] reset # Resets form state.
const { reset } = useForm( { name: 'Rimuru' } ) ... reset({ name: 'Rimuru Tempest' }) /// Validates new data, triggers validation reset( { name: 'Rimuru Tempest' }, { validate: true } ) merge # Unlike reset, merge will merge a new partial form to the new form.
const { merge } = useForm( { name: 'Rimuru', age: '40' } ) ... merge({ age: '39' }) onChange # Returns a method to change key value.
const { onChange } = useForm( { name: 'Rimuru' } ) ... onChange('name') /// Validates form on change onChange('name', { validate: true }) \u0026lt;input onChange={onChange('name')} /\u0026gt; changeValue # Simplified version of onChange, without the return method.
const { changeValue } = useForm( { name: 'Rimuru', age: '40' } ) ... changeValue('name', 'Rimuru Tempest') /// Validates form on change changeValue('name', 'Rimuru Tempest', { validate: true }) getValue # Return the value for the matched key.
const { changeValue } = useForm( { name: 'Rimuru' } ) ... getValue('name') /// Rimuru resetTouch # Clears touch\u0026rsquo;s for the form.
const { resetTouch } = useForm( ... ) ... resetTouch() resetTouch # Revert last change if available.
const { undo } = useForm() ... undo() redo # Forward last undo if available.
const { redo } = useForm() ... redo() All actions # useForm returns State and Actions.
All actions available on useForm:
Name Type Default Description form object formData Form data errors { [form path]: [path error messages] } undefined Depends if useForm validate is set. (ex: { \u0026lsquo;user.name\u0026rsquo;: [\u0026lsquo;Name is required\u0026rsquo;] }) isValid boolean false Form state by default is false if errors are undefined or an empty object touches { [form path]: boolean } {} Form touches (ex: { \u0026lsquo;user.name\u0026rsquo;: true }) isTouched boolean false Form touches state by default is false if touches are undefined or an empty object context object Form State Context, mainly for use in FormProvider formState object object Virtual Form Data, that provides a virtual representation of the form data to individually find errors/isTouched/isValid on each key (includes deep keys) `}),e.add({id:5,href:"/resourge-react-form/docs/api/form-provider/",title:"Context Provider",description:"Provider with context available for more complex forms.",content:`FormProvider # Context provider for more complex forms. With nested components we can use other hooks to acces the form. We can use useFormField for accessing the especific field.
import React from 'react'; import { FormProvider, useForm } from '@resourge/react-form' export function CustomElement() { // field is the same as doing field('name') const { field, formContext } = useFormField('name') return ( \u0026lt;\u0026gt; \u0026lt;span\u0026gt; { formContext.isValid ? \u0026quot;Valid\u0026quot; : \u0026quot;Invalid\u0026quot; } CustomElement \u0026lt;/span\u0026gt; \u0026lt;input {...field} /\u0026gt; \u0026lt;/\u0026gt; ) } export function App() { const { context } = useForm( ... ) return ( \u0026lt;FormProvider context={context}\u0026gt; \u0026lt;CustomElement /\u0026gt; ... \u0026lt;/FormProvider\u0026gt; ) } `}),e.add({id:6,href:"/resourge-react-form/docs/api/hooks/",title:"Hooks",description:"Custom hooks related with form.",content:"useForm # This hook is the main hook for creating the form:\nimport React, { useState } from 'react'; import { useForm } from '@resourge/react-form'; export default function LoginForm() { const { isValid, field, handleSubmit } = useForm( { username: '', password: '' } ) Options we can use on useForm:\nName Type Required Description validateDefault boolean false Set\u0026rsquo;s global validation. False by default validate (form: T) =\u0026gt; Promise\u0026lt;void\u0026gt; false Method to validate form. Usually with some kind of validator. (like yup, zod, joi, etc) isValid ({ form, isValid, errors }) =\u0026gt; boolean false Method to define if form is valid onErrors (errors: any[]) =\u0026gt; FormErrors false Local method to treat errors. onTouch (key: FormKey\u0026lt;T\u0026gt;, value: unknown, previousValue: unknown) =\u0026gt; void false Method called every time a value is changed useFormField # 💡 This hook will be only works when Form Provider is available When using form provider we can use useFormField for accesing the field when nested in component.\nexport function CustomElement() { // field is the same as doing field('name') const { field, formContext } = useFormField('name') return ( \u0026lt;\u0026gt; \u0026lt;span\u0026gt; { formContext.isValid ? \u0026quot;Valid\u0026quot; : \u0026quot;Invalid\u0026quot; } CustomElement \u0026lt;/span\u0026gt; \u0026lt;input {...field} /\u0026gt; \u0026lt;/\u0026gt; ) } useController # For more complex and deep forms, where render\u0026rsquo;s can impact performance (like list\u0026rsquo;s with multiple elements) Controller serves to minimize the impact a render can have on react, by only updating children if key name is touched.\nimport React from 'react'; import { Controller, useFormField, useForm } from '@resourge/react-form' function CustomElement({ value }: { value: number }) { const { field } = useController() return ( \u0026lt;div\u0026gt; { value } \u0026lt;button onClick={() =\u0026gt; { field.onChange \u0026amp;\u0026amp; field.onChange(Math.random()) }} \u0026gt; Update with random value \u0026lt;/button\u0026gt; \u0026lt;/div\u0026gt; ) } export function App() { const { context, form } = useForm({ list: Array.from({ length: 1000 }).map((_, index) =\u0026gt; index + 1) }) return ( \u0026lt;div style={{ display: 'flex', flexDirection: 'column' }}\u0026gt; { form.list.map((value, index) =\u0026gt; ( \u0026lt;Controller key={`${index}`} name={`list[${index}]`} context={context} \u0026gt; \u0026lt;CustomElement value={value} /\u0026gt; \u0026lt;/Controller\u0026gt; )) } \u0026lt;/div\u0026gt; ) } "}),e.add({id:7,href:"/resourge-react-form/docs/api/schema-validations/",title:"Schemas Validation",description:"Schema for validation is the best way to validate your form.",content:`Yup # 💡 Only needed when using Yup as schema validation To simplify the process of converting errors from diferent validation packages like joi, yup, zod, ajv, etc to useForm hook lookalike errors, use setDefaultOnError. You only need to setup this on the initialization of the application in this case App.tsx.
setDefaultOnError will, by default (unless onError from Form Options is set), customize the errors to fit useForm errors
// In App.tsx import { setDefaultOnError } from '@resourge/react-form' setDefaultOnError((errors: any) =\u0026gt; { // Customize errors to fit the model // [{ path, errors }] return [] }); Note: We plan to add more default validations in the future. If you have one and want to share, please do and contribute.
For yup validation, setFormYupValidation
// In App.tsx import { setDefaultOnError } from '@resourge/react-form' setDefaultOnError((errors: any) =\u0026gt; { // Customize errors to fit the model // [{ path, errors }] return [] }); Example:
type UserType = { name: string age: number email: string createdAt?: string } export class UserModel { public name = '' public age = 18 public email = '' public createdAt?: Date constructor(model?: UserType) { if (model) { this.name = model.name this.age = model.age this.email = model.email if(model.createdAt) { this.createdAt = new Date(model.createdAt) } } } } const schema = object({ name: string().required(), age: number().required().positive().integer(), email: string().email(), }); const { form, ...} = useForm\u0026lt;UserModel\u0026gt;(new UserModel(model), { validate: (form: UserModel, changedKeys) =\u0026gt; { return schema.validate(form, changedKeys) }, }) Resource Scheme # We have created a better improved shceme validation to replace the other libraries like, yup, zod, fast-validator, etc.
This libraries has all improvements, comes with extra essentials validations and until know is the fastest one we know. You can get it in here Resource Schema.
export type UserType = { name: string age: number location: LocationType hobbies: Array\u0026lt;keyof typeof HobbiesEnum\u0026gt; } export class UserModel { public name = '' public age = 16 public location: LocationType = { address: '', city: '', postalCode: '', phoneNumber: '' } public hobbies: Array\u0026lt;keyof typeof HobbiesEnum\u0026gt; = [] constructor(model?: UserType) { if (model) { this.name = model.name this.age = model.age this.location = model.location } } } const schema = object\u0026lt;UserModel\u0026gt;({ name: string().min(10).required(), age: number().min(16).required(), location: object({ city: string().required(), address: string().required(), postalCode: string().postalCode(PostalCodes.PT).required(), phoneNumber: string().phoneNumber(PhoneNumbers.am_AM).required() }) }).compile(); export const useUserModel = (model?: UserType) =\u0026gt; { return useForm\u0026lt;UserModel\u0026gt;(new UserModel(model), { validate: (form: UserModel, changedKeys) =\u0026gt; { return schema.validate(form, changedKeys) }, }) } In the form component when you trigger the handlerSubmit function will validate the form with the schema. Preventing to submit the form in case theres errors in the form. We can read the errors by using Errors
`}),e.add({id:8,href:"/resourge-react-form/docs/help/",title:"Help",description:"Help React Form.",content:""}),e.add({id:9,href:"/resourge-react-form/docs/help/how-to-update/",title:"How to Update",description:"Regularly update the installed react-form while we build more features for the package.",content:` 💡 Learn more about semantic versioning and advanced range syntax. Check for outdated packages # The npm outdated command will check the registry to see if any (or, specific) installed packages are currently outdated:
npm outdated [[\u0026lt;@scope\u0026gt;/]\u0026lt;pkg\u0026gt; ...] Update packages # The npm update command will update all the packages listed to the latest version (specified by the tag config), respecting semver:
npm update [\u0026lt;pkg\u0026gt;...] `}),e.add({id:10,href:"/resourge-react-form/docs/help/troubleshooting/",title:"Troubleshooting",description:"Solutions to common problems.",content:`Problems updating npm packages # Delete the ./node_modules folder, and run again:
npm install Problems with cache # Delete the temporary directories:
npm run clean `}),e.add({id:11,href:"/resourge-react-form/docs/help/faq/",title:"FAQ",description:"Answers to frequently asked questions.",content:`Keyboard shortcuts for search? # focus: Ctrl + / select: ↓ and ↑ open: Enter close: Esc Can I get support? # Create a topic:
GitHub Contact the creator? # GitHub (José Oliveira) `}),e.add({id:12,href:"/resourge-react-form/docs/",title:"React Form",description:"React Form.",content:""}),search.addEventListener("input",t,!0);function t(){const s=5;var n=this.value,o=e.search(n,{limit:s,enrich:!0});const t=new Map;for(const e of o.flatMap(e=>e.result)){if(t.has(e.doc.href))continue;t.set(e.doc.href,e.doc)}if(suggestions.innerHTML="",suggestions.classList.remove("d-none"),t.size===0&&n){const e=document.createElement("div");e.innerHTML=`No results for "<strong>${n}</strong>"`,e.classList.add("suggestion__no-results"),suggestions.appendChild(e);return}for(const[r,a]of t){const n=document.createElement("div");suggestions.appendChild(n);const e=document.createElement("a");e.href=r,n.appendChild(e);const o=document.createElement("span");o.textContent=a.title,o.classList.add("suggestion__title"),e.appendChild(o);const i=document.createElement("span");if(i.textContent=a.description,i.classList.add("suggestion__description"),e.appendChild(i),suggestions.appendChild(n),suggestions.childElementCount==s)break}}})()